---
layout: "@/layouts/post-layout.astro"
title: "My Commonly Used React Hooks"
description: "React hooks are the common way to interact with the component in various behaviour. Before React hooks being introduced, we are exposed with component lifecycle and component state with class based component. Now,  we can do the same thing with React hooks."
pubDate: "1701258248000"
image: "/images/blog/my-commonly-used-react-hooks.webp"
category: "tutorial"
tags: 
  - "react"
  - "javascript"
  - "beginner"
coverColor: "#F7FEE7"
author: "Muhamad Amir Azmi"
slug: "my-commonly-used-react-hooks"
deactivate: false
---
React hooks are the common way to interact with the component in various behaviour. Before React hooks being introduced, we are exposed with component lifecycle and component state with class based component. Now,  we can do the same thing with React hooks.

## From Official Docs

There are a lot of React hooks that developer can used in React. Each hooks has its own functionality which makes developer life easier. For example, `useState` and `useReducer` makes the component state management easier instead of using `var`, `let` or `const` to hold our component state.

In official docs also show us how to create our own custom hooks which can abstract away our component logic from our rendering component. Custom hooks also can contains built in React hooks.

Can read more details on React hooks from the [official documentation](https://react.dev/). Here I just want to share my most commonly used React hooks that I use everyday in every React project:

- [`useState`](#`useState`)
- [`useRef`](#`useRef`)
- [`useEffect`](#`useEffect`)

    <a name="`useState`"></a>
## `useState` - Handle Component State

In every React app that I have built, there is always a need to track and keep state or data changes within the component. With `useState`, instead of keeping the state with `var`, `let` and `const` which not a good thing to do in React, I will use `useState`. There are few ways of using `useState`.

1. [For toggle - modal, popup, hide/show](#`useState`-toggle)
2. Form input data store
3. Previous, current and future state
4. Array or object organization

    <a name="`useState`-toggle"></a>
### Toggle

The most common usage of `useState` is use as toggle. We can create a state which holds boolean value either `true` or `false` and conditionally renders the component depends on the state boolean value.

For example, we can use `useState` to handle the toggle of popup component as below.

```jsx
const [show, setShow] = `useState`(false)

if(show) return (
  <div>
    <h1>Show Popup</h1>
    <span onClick={()=>setShow(!show)}>Close</span>
  </div>
)

if(!show) return (
  <button onClick={()=>setShow(!show)}>Open Popup</button>
)

```

From this code, we can refactor by extracting the click handle and put it into separate reusable function. This will make our component more optimize since the application do not need to recreate anonymous function each time our component re-renders.

```jsx
const [show, setShow] = `useState`(false)

const toggle = () => setShow(!show)

if(show) return (
  <div>
    <h1>Show Popup</h1>
    <span onClick={toggle}>Close</span>
  </div>
)

if(!show) return (
  <button onClick={toggle}>Open Popup</button>
)
```

We also can use toggle `useState` to hold our loading state. For example, when the component is fetching some data when user click on a button, we want to show some loading state or loading message to user so that user understand that the data fetching is happening especially when the data fetching takes quite some time to complete.

```jsx
const [data, setData] = `useState`([])
const [loading, setLoading] = `useState`(false)

const getNewData = async () => {
  setLoading(true)
  const newData = await fetch('...')
  setData(newData)
  setLoading(false)
}

if(loading) return (
  <div>Application is fetching new data..</div>
)

if(!loading) return (
  <div>
    <div>
      {data.map((item, k)=><div key={k}>{item.name}</div>)}
    </div>
    <button>Fetch New Data</button>
  </div>
)

```

The code above shows that, on initial component load, there is no items in data array. The component only renders a button with `Fetch New Data label`. The initial loading state is false.

Then, when user click on the button, the loading state changed to true which will let the component renders the `Application is fetching new data..` text on the screen while the application is fetching the new data.

After quite some time, the data state updated and the loading state changed to false which will let the component renders the original template with a list of `item.name` on the screen.

These are two quick example how to use `useState` as toggle state. There are a lot of situation where we might need to use two to five toggle state in one component depends on how complicated the component is.

### Form Input Data Store

…

### Previous, Current and Future State

…

### `useState` Gotcha - Remember This

Each time the state changes, the component will be rerender. Make sure to use `useState` when neccessery and component rerender is needed. This is because, when component is rerender due to state change, some of things might not work well. CSS animation for example, one of things that I always encounter is that, the animation does not work well because some of the JSX depending on state to hide and show.

This can be demonstrate with building simple popup modal with some ease in out animation. If the modal JSX depends on toggle state directly, it will just show and hide without any animation due to the missing HTML element inside HTML DOM.

## `useRef` - Referencing DOM Element
...
## `useEffect` - Handle The Component Event
...